<h2>Listener Ensures Messages Are Saved</h2>

<p>We want to ensure that messages are saved, even if we encounter errors processing them.&nbsp; The Listener therefore operates as follows:</p>

<ol>
	<li>Saves&nbsp;the message into Resource <code>Messages</code> (table <code>MessageAudits</code>)<br />
	&nbsp;</li>
	<li>Updates <code>MessageAudits</code>&nbsp;(via the function described below) to&nbsp;process&nbsp;in a <em><strong>separate&nbsp;transaction</strong></em>&nbsp;(recall, each restPut/Post is a separate transaction</li>
</ol>

<p>&nbsp;</p>

<h2>Function on MessageAudit triggers Table Event for Re-Tryable Message Processing</h2>

<p>Processing is exposed as a function <code>ProcessPayload.&nbsp; MessageAudit.ProcessedStatus</code> tracks whether the&nbsp;message is successfully processed.&nbsp; The function sets this, which triggers the event below (update only - not on insert).</p>

<p>The actual processing is simple - the <code>MessageAudit</code> payload (<code>msgContent</code>) is posted into the&nbsp;<code>Charges</code>&nbsp;resource, creating rows in the <code>Charges</code> and <code>Talks</code> tables.&nbsp; These would typically have further logic (e.g., to adjust General Ledger, etc).</p>

<p>&nbsp;</p>

<h3>Error Retry</h3>

<p>This function is typically triggered from the Listener as described above.&nbsp; But putting the processing logic on the table also makes processing re-tryable - you can correct <code>MessageAudit.MsgContext</code>&nbsp;(or related data), then simply update the&nbsp;<code>MessageAudit.</code></p>
