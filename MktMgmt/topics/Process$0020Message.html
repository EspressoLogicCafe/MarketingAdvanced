<h2>MessageAudit Posts (via Resource PersistCharges) is a persisted, <strong><em>without</em></strong> processing</h2>

<p>We want to ensure that messages are saved, even if we encounter errors <em>processing</em> them.&nbsp; So, instead of creating an&nbsp;event&nbsp;on the &nbsp;<code>MessageAudits</code>&nbsp;table (which would fire in the same transaction), we use the Response Event described below.&nbsp;</p>

<p>&nbsp;</p>

<h2>Response Handler calls MessageAudit&nbsp;Function to trigger&nbsp;Table Event for Re-Tryable Message Processing</h2>

<p>The Response Handler&nbsp;uses the txsummary to Update the posted&nbsp;<code>MessageAudits</code>&nbsp;to&nbsp;process&nbsp;in a <em><strong>separate&nbsp;transaction</strong></em>&nbsp;(recall, each restPut/Post is a separate transaction).</p>

<p>Processing is exposed as a function <code>ProcessPayload.&nbsp; MessageAudit.ProcessedStatus</code> tracks whether the&nbsp;message is successfully processed.&nbsp; The function sets this, which triggers the event below (update only - not on insert).</p>

<p>The actual processing is simple - the <code>MessageAudit</code> payload (<code>msgContent</code>) is posted into the&nbsp;<code>Charges</code>&nbsp;resource, creating rows in the <code>Charges</code> and <code>Talks</code> tables.&nbsp; These would typically have further logic (e.g., to adjust General Ledger, etc).</p>

<p>Note: we could have issued this code in the Listener, but using a response event enables the caller (MktConfOffers) to communicate either by messages or APIs.</p>

<p>&nbsp;</p>

<h3>Error Retry</h3>

<p>This function is typically triggered from the Listener as described above.&nbsp; But putting the processing logic on the table also makes processing re-tryable - you can correct <code>MessageAudit.MsgContext</code>&nbsp;(or related data), then simply update the&nbsp;<code>MessageAudit.</code></p>
